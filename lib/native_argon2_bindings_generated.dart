// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/native_argon2.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class NativeArgon2Bindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeArgon2Bindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeArgon2Bindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// Global flag to determine if we are wiping internal memory buffers. This flag
  /// is defined in core.c and defaults to 1 (wipe internal memory).
  late final ffi.Pointer<ffi.Int> _FLAG_clear_internal_memory =
      _lookup<ffi.Int>('FLAG_clear_internal_memory');

  int get FLAG_clear_internal_memory => _FLAG_clear_internal_memory.value;

  set FLAG_clear_internal_memory(int value) =>
      _FLAG_clear_internal_memory.value = value;

  /// Function that gives the string representation of an argon2_type.
  /// @param type The argon2_type that we want the string for
  /// @param uppercase Whether the string should have the first letter uppercase
  /// @return NULL if invalid type, otherwise the string representation.
  ffi.Pointer<ffi.Char> argon2_type2string(Argon2_type type, int uppercase) {
    return _argon2_type2string(type.value, uppercase);
  }

  late final _argon2_type2stringPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt, ffi.Int)
        >
      >('argon2_type2string');
  late final _argon2_type2string = _argon2_type2stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  /// Function that performs memory-hard hashing with certain degree of parallelism
  /// @param  context  Pointer to the Argon2 internal structure
  /// @return Error code if smth is wrong, ARGON2_OK otherwise
  int argon2_ctx(ffi.Pointer<argon2_context> context, Argon2_type type) {
    return _argon2_ctx(context, type.value);
  }

  late final _argon2_ctxPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<argon2_context>, ffi.UnsignedInt)
        >
      >('argon2_ctx');
  late final _argon2_ctx = _argon2_ctxPtr
      .asFunction<int Function(ffi.Pointer<argon2_context>, int)>();

  /// Hashes a password with Argon2i, producing an encoded hash
  /// @param t_cost Number of iterations
  /// @param m_cost Sets memory usage to m_cost kibibytes
  /// @param parallelism Number of threads and compute lanes
  /// @param pwd Pointer to password
  /// @param pwdlen Password size in bytes
  /// @param salt Pointer to salt
  /// @param saltlen Salt size in bytes
  /// @param hashlen Desired length of the hash in bytes
  /// @param encoded Buffer where to write the encoded hash
  /// @param encodedlen Size of the buffer (thus max size of the encoded hash)
  /// @pre   Different parallelism levels will give different results
  /// @pre   Returns ARGON2_OK if successful
  int argon2i_hash_encoded(
    int t_cost,
    int m_cost,
    int parallelism,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
    ffi.Pointer<ffi.Void> salt,
    int saltlen,
    int hashlen,
    ffi.Pointer<ffi.Char> encoded,
    int encodedlen,
  ) {
    return _argon2i_hash_encoded(
      t_cost,
      m_cost,
      parallelism,
      pwd,
      pwdlen,
      salt,
      saltlen,
      hashlen,
      encoded,
      encodedlen,
    );
  }

  late final _argon2i_hash_encodedPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
          )
        >
      >('argon2i_hash_encoded');
  late final _argon2i_hash_encoded = _argon2i_hash_encodedPtr
      .asFunction<
        int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          int,
        )
      >();

  /// Hashes a password with Argon2i, producing a raw hash at @hash
  /// @param t_cost Number of iterations
  /// @param m_cost Sets memory usage to m_cost kibibytes
  /// @param parallelism Number of threads and compute lanes
  /// @param pwd Pointer to password
  /// @param pwdlen Password size in bytes
  /// @param salt Pointer to salt
  /// @param saltlen Salt size in bytes
  /// @param hash Buffer where to write the raw hash - updated by the function
  /// @param hashlen Desired length of the hash in bytes
  /// @pre   Different parallelism levels will give different results
  /// @pre   Returns ARGON2_OK if successful
  int argon2i_hash_raw(
    int t_cost,
    int m_cost,
    int parallelism,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
    ffi.Pointer<ffi.Void> salt,
    int saltlen,
    ffi.Pointer<ffi.Void> hash,
    int hashlen,
  ) {
    return _argon2i_hash_raw(
      t_cost,
      m_cost,
      parallelism,
      pwd,
      pwdlen,
      salt,
      saltlen,
      hash,
      hashlen,
    );
  }

  late final _argon2i_hash_rawPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
          )
        >
      >('argon2i_hash_raw');
  late final _argon2i_hash_raw = _argon2i_hash_rawPtr
      .asFunction<
        int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >();

  int argon2d_hash_encoded(
    int t_cost,
    int m_cost,
    int parallelism,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
    ffi.Pointer<ffi.Void> salt,
    int saltlen,
    int hashlen,
    ffi.Pointer<ffi.Char> encoded,
    int encodedlen,
  ) {
    return _argon2d_hash_encoded(
      t_cost,
      m_cost,
      parallelism,
      pwd,
      pwdlen,
      salt,
      saltlen,
      hashlen,
      encoded,
      encodedlen,
    );
  }

  late final _argon2d_hash_encodedPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
          )
        >
      >('argon2d_hash_encoded');
  late final _argon2d_hash_encoded = _argon2d_hash_encodedPtr
      .asFunction<
        int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          int,
        )
      >();

  int argon2d_hash_raw(
    int t_cost,
    int m_cost,
    int parallelism,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
    ffi.Pointer<ffi.Void> salt,
    int saltlen,
    ffi.Pointer<ffi.Void> hash,
    int hashlen,
  ) {
    return _argon2d_hash_raw(
      t_cost,
      m_cost,
      parallelism,
      pwd,
      pwdlen,
      salt,
      saltlen,
      hash,
      hashlen,
    );
  }

  late final _argon2d_hash_rawPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
          )
        >
      >('argon2d_hash_raw');
  late final _argon2d_hash_raw = _argon2d_hash_rawPtr
      .asFunction<
        int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >();

  int argon2id_hash_encoded(
    int t_cost,
    int m_cost,
    int parallelism,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
    ffi.Pointer<ffi.Void> salt,
    int saltlen,
    int hashlen,
    ffi.Pointer<ffi.Char> encoded,
    int encodedlen,
  ) {
    return _argon2id_hash_encoded(
      t_cost,
      m_cost,
      parallelism,
      pwd,
      pwdlen,
      salt,
      saltlen,
      hashlen,
      encoded,
      encodedlen,
    );
  }

  late final _argon2id_hash_encodedPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
          )
        >
      >('argon2id_hash_encoded');
  late final _argon2id_hash_encoded = _argon2id_hash_encodedPtr
      .asFunction<
        int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          int,
        )
      >();

  int argon2id_hash_raw(
    int t_cost,
    int m_cost,
    int parallelism,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
    ffi.Pointer<ffi.Void> salt,
    int saltlen,
    ffi.Pointer<ffi.Void> hash,
    int hashlen,
  ) {
    return _argon2id_hash_raw(
      t_cost,
      m_cost,
      parallelism,
      pwd,
      pwdlen,
      salt,
      saltlen,
      hash,
      hashlen,
    );
  }

  late final _argon2id_hash_rawPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
          )
        >
      >('argon2id_hash_raw');
  late final _argon2id_hash_raw = _argon2id_hash_rawPtr
      .asFunction<
        int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >();

  /// generic function underlying the above ones
  int argon2_hash(
    int t_cost,
    int m_cost,
    int parallelism,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
    ffi.Pointer<ffi.Void> salt,
    int saltlen,
    ffi.Pointer<ffi.Void> hash,
    int hashlen,
    ffi.Pointer<ffi.Char> encoded,
    int encodedlen,
    Argon2_type type,
    int version,
  ) {
    return _argon2_hash(
      t_cost,
      m_cost,
      parallelism,
      pwd,
      pwdlen,
      salt,
      saltlen,
      hash,
      hashlen,
      encoded,
      encodedlen,
      type.value,
      version,
    );
  }

  late final _argon2_hashPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.Pointer<ffi.Char>,
            ffi.Size,
            ffi.UnsignedInt,
            ffi.Uint32,
          )
        >
      >('argon2_hash');
  late final _argon2_hash = _argon2_hashPtr
      .asFunction<
        int Function(
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          int,
          int,
        )
      >();

  /// Verifies a password against an encoded string
  /// Encoded string is restricted as in validate_inputs()
  /// @param encoded String encoding parameters, salt, hash
  /// @param pwd Pointer to password
  /// @pre   Returns ARGON2_OK if successful
  int argon2i_verify(
    ffi.Pointer<ffi.Char> encoded,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
  ) {
    return _argon2i_verify(encoded, pwd, pwdlen);
  }

  late final _argon2i_verifyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
          )
        >
      >('argon2i_verify');
  late final _argon2i_verify = _argon2i_verifyPtr
      .asFunction<
        int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int)
      >();

  int argon2d_verify(
    ffi.Pointer<ffi.Char> encoded,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
  ) {
    return _argon2d_verify(encoded, pwd, pwdlen);
  }

  late final _argon2d_verifyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
          )
        >
      >('argon2d_verify');
  late final _argon2d_verify = _argon2d_verifyPtr
      .asFunction<
        int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int)
      >();

  int argon2id_verify(
    ffi.Pointer<ffi.Char> encoded,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
  ) {
    return _argon2id_verify(encoded, pwd, pwdlen);
  }

  late final _argon2id_verifyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
          )
        >
      >('argon2id_verify');
  late final _argon2id_verify = _argon2id_verifyPtr
      .asFunction<
        int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int)
      >();

  /// generic function underlying the above ones
  int argon2_verify(
    ffi.Pointer<ffi.Char> encoded,
    ffi.Pointer<ffi.Void> pwd,
    int pwdlen,
    Argon2_type type,
  ) {
    return _argon2_verify(encoded, pwd, pwdlen, type.value);
  }

  late final _argon2_verifyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>,
            ffi.Size,
            ffi.UnsignedInt,
          )
        >
      >('argon2_verify');
  late final _argon2_verify = _argon2_verifyPtr
      .asFunction<
        int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int, int)
      >();

  /// Argon2d: Version of Argon2 that picks memory blocks depending
  /// on the password and salt. Only for side-channel-free
  /// environment!!
  ///
  /// @param  context  Pointer to current Argon2 context
  /// @return  Zero if successful, a non zero error code otherwise
  int argon2d_ctx(ffi.Pointer<argon2_context> context) {
    return _argon2d_ctx(context);
  }

  late final _argon2d_ctxPtr =
      _lookup<
        ffi.NativeFunction<ffi.Int Function(ffi.Pointer<argon2_context>)>
      >('argon2d_ctx');
  late final _argon2d_ctx = _argon2d_ctxPtr
      .asFunction<int Function(ffi.Pointer<argon2_context>)>();

  /// Argon2i: Version of Argon2 that picks memory blocks
  /// independent on the password and salt. Good for side-channels,
  /// but worse w.r.t. tradeoff attacks if only one pass is used.
  ///
  /// @param  context  Pointer to current Argon2 context
  /// @return  Zero if successful, a non zero error code otherwise
  int argon2i_ctx(ffi.Pointer<argon2_context> context) {
    return _argon2i_ctx(context);
  }

  late final _argon2i_ctxPtr =
      _lookup<
        ffi.NativeFunction<ffi.Int Function(ffi.Pointer<argon2_context>)>
      >('argon2i_ctx');
  late final _argon2i_ctx = _argon2i_ctxPtr
      .asFunction<int Function(ffi.Pointer<argon2_context>)>();

  /// Argon2id: Version of Argon2 where the first half-pass over memory is
  /// password-independent, the rest are password-dependent (on the password and
  /// salt). OK against side channels (they reduce to 1/2-pass Argon2i), and
  /// better with w.r.t. tradeoff attacks (similar to Argon2d).
  ///
  /// @param  context  Pointer to current Argon2 context
  /// @return  Zero if successful, a non zero error code otherwise
  int argon2id_ctx(ffi.Pointer<argon2_context> context) {
    return _argon2id_ctx(context);
  }

  late final _argon2id_ctxPtr =
      _lookup<
        ffi.NativeFunction<ffi.Int Function(ffi.Pointer<argon2_context>)>
      >('argon2id_ctx');
  late final _argon2id_ctx = _argon2id_ctxPtr
      .asFunction<int Function(ffi.Pointer<argon2_context>)>();

  /// Verify if a given password is correct for Argon2d hashing
  /// @param  context  Pointer to current Argon2 context
  /// @param  hash  The password hash to verify. The length of the hash is
  /// specified by the context outlen member
  /// @return  Zero if successful, a non zero error code otherwise
  int argon2d_verify_ctx(
    ffi.Pointer<argon2_context> context,
    ffi.Pointer<ffi.Char> hash,
  ) {
    return _argon2d_verify_ctx(context, hash);
  }

  late final _argon2d_verify_ctxPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<argon2_context>, ffi.Pointer<ffi.Char>)
        >
      >('argon2d_verify_ctx');
  late final _argon2d_verify_ctx = _argon2d_verify_ctxPtr
      .asFunction<
        int Function(ffi.Pointer<argon2_context>, ffi.Pointer<ffi.Char>)
      >();

  /// Verify if a given password is correct for Argon2i hashing
  /// @param  context  Pointer to current Argon2 context
  /// @param  hash  The password hash to verify. The length of the hash is
  /// specified by the context outlen member
  /// @return  Zero if successful, a non zero error code otherwise
  int argon2i_verify_ctx(
    ffi.Pointer<argon2_context> context,
    ffi.Pointer<ffi.Char> hash,
  ) {
    return _argon2i_verify_ctx(context, hash);
  }

  late final _argon2i_verify_ctxPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<argon2_context>, ffi.Pointer<ffi.Char>)
        >
      >('argon2i_verify_ctx');
  late final _argon2i_verify_ctx = _argon2i_verify_ctxPtr
      .asFunction<
        int Function(ffi.Pointer<argon2_context>, ffi.Pointer<ffi.Char>)
      >();

  /// Verify if a given password is correct for Argon2id hashing
  /// @param  context  Pointer to current Argon2 context
  /// @param  hash  The password hash to verify. The length of the hash is
  /// specified by the context outlen member
  /// @return  Zero if successful, a non zero error code otherwise
  int argon2id_verify_ctx(
    ffi.Pointer<argon2_context> context,
    ffi.Pointer<ffi.Char> hash,
  ) {
    return _argon2id_verify_ctx(context, hash);
  }

  late final _argon2id_verify_ctxPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<argon2_context>, ffi.Pointer<ffi.Char>)
        >
      >('argon2id_verify_ctx');
  late final _argon2id_verify_ctx = _argon2id_verify_ctxPtr
      .asFunction<
        int Function(ffi.Pointer<argon2_context>, ffi.Pointer<ffi.Char>)
      >();

  /// generic function underlying the above ones
  int argon2_verify_ctx(
    ffi.Pointer<argon2_context> context,
    ffi.Pointer<ffi.Char> hash,
    Argon2_type type,
  ) {
    return _argon2_verify_ctx(context, hash, type.value);
  }

  late final _argon2_verify_ctxPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<argon2_context>,
            ffi.Pointer<ffi.Char>,
            ffi.UnsignedInt,
          )
        >
      >('argon2_verify_ctx');
  late final _argon2_verify_ctx = _argon2_verify_ctxPtr
      .asFunction<
        int Function(ffi.Pointer<argon2_context>, ffi.Pointer<ffi.Char>, int)
      >();

  /// Get the associated error message for given error code
  /// @return  The error message associated with the given error code
  ffi.Pointer<ffi.Char> argon2_error_message(int error_code) {
    return _argon2_error_message(error_code);
  }

  late final _argon2_error_messagePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
        'argon2_error_message',
      );
  late final _argon2_error_message = _argon2_error_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Returns the encoded hash length for the given input parameters
  /// @param t_cost  Number of iterations
  /// @param m_cost  Memory usage in kibibytes
  /// @param parallelism  Number of threads; used to compute lanes
  /// @param saltlen  Salt size in bytes
  /// @param hashlen  Hash size in bytes
  /// @param type The argon2_type that we want the encoded length for
  /// @return  The encoded hash length in bytes
  int argon2_encodedlen(
    int t_cost,
    int m_cost,
    int parallelism,
    int saltlen,
    int hashlen,
    Argon2_type type,
  ) {
    return _argon2_encodedlen(
      t_cost,
      m_cost,
      parallelism,
      saltlen,
      hashlen,
      type.value,
    );
  }

  late final _argon2_encodedlenPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Size Function(
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.Uint32,
            ffi.UnsignedInt,
          )
        >
      >('argon2_encodedlen');
  late final _argon2_encodedlen = _argon2_encodedlenPtr
      .asFunction<int Function(int, int, int, int, int, int)>();
}

/// Error codes
enum Argon2_ErrorCodes {
  ARGON2_OK(0),
  ARGON2_OUTPUT_PTR_NULL(-1),
  ARGON2_OUTPUT_TOO_SHORT(-2),
  ARGON2_OUTPUT_TOO_LONG(-3),
  ARGON2_PWD_TOO_SHORT(-4),
  ARGON2_PWD_TOO_LONG(-5),
  ARGON2_SALT_TOO_SHORT(-6),
  ARGON2_SALT_TOO_LONG(-7),
  ARGON2_AD_TOO_SHORT(-8),
  ARGON2_AD_TOO_LONG(-9),
  ARGON2_SECRET_TOO_SHORT(-10),
  ARGON2_SECRET_TOO_LONG(-11),
  ARGON2_TIME_TOO_SMALL(-12),
  ARGON2_TIME_TOO_LARGE(-13),
  ARGON2_MEMORY_TOO_LITTLE(-14),
  ARGON2_MEMORY_TOO_MUCH(-15),
  ARGON2_LANES_TOO_FEW(-16),
  ARGON2_LANES_TOO_MANY(-17),

  /// NULL ptr with non-zero length
  ARGON2_PWD_PTR_MISMATCH(-18),

  /// NULL ptr with non-zero length
  ARGON2_SALT_PTR_MISMATCH(-19),

  /// NULL ptr with non-zero length
  ARGON2_SECRET_PTR_MISMATCH(-20),

  /// NULL ptr with non-zero length
  ARGON2_AD_PTR_MISMATCH(-21),
  ARGON2_MEMORY_ALLOCATION_ERROR(-22),
  ARGON2_FREE_MEMORY_CBK_NULL(-23),
  ARGON2_ALLOCATE_MEMORY_CBK_NULL(-24),
  ARGON2_INCORRECT_PARAMETER(-25),
  ARGON2_INCORRECT_TYPE(-26),
  ARGON2_OUT_PTR_MISMATCH(-27),
  ARGON2_THREADS_TOO_FEW(-28),
  ARGON2_THREADS_TOO_MANY(-29),
  ARGON2_MISSING_ARGS(-30),
  ARGON2_ENCODING_FAIL(-31),
  ARGON2_DECODING_FAIL(-32),
  ARGON2_THREAD_FAIL(-33),
  ARGON2_DECODING_LENGTH_FAIL(-34),
  ARGON2_VERIFY_MISMATCH(-35);

  final int value;
  const Argon2_ErrorCodes(this.value);

  static Argon2_ErrorCodes fromValue(int value) => switch (value) {
    0 => ARGON2_OK,
    -1 => ARGON2_OUTPUT_PTR_NULL,
    -2 => ARGON2_OUTPUT_TOO_SHORT,
    -3 => ARGON2_OUTPUT_TOO_LONG,
    -4 => ARGON2_PWD_TOO_SHORT,
    -5 => ARGON2_PWD_TOO_LONG,
    -6 => ARGON2_SALT_TOO_SHORT,
    -7 => ARGON2_SALT_TOO_LONG,
    -8 => ARGON2_AD_TOO_SHORT,
    -9 => ARGON2_AD_TOO_LONG,
    -10 => ARGON2_SECRET_TOO_SHORT,
    -11 => ARGON2_SECRET_TOO_LONG,
    -12 => ARGON2_TIME_TOO_SMALL,
    -13 => ARGON2_TIME_TOO_LARGE,
    -14 => ARGON2_MEMORY_TOO_LITTLE,
    -15 => ARGON2_MEMORY_TOO_MUCH,
    -16 => ARGON2_LANES_TOO_FEW,
    -17 => ARGON2_LANES_TOO_MANY,
    -18 => ARGON2_PWD_PTR_MISMATCH,
    -19 => ARGON2_SALT_PTR_MISMATCH,
    -20 => ARGON2_SECRET_PTR_MISMATCH,
    -21 => ARGON2_AD_PTR_MISMATCH,
    -22 => ARGON2_MEMORY_ALLOCATION_ERROR,
    -23 => ARGON2_FREE_MEMORY_CBK_NULL,
    -24 => ARGON2_ALLOCATE_MEMORY_CBK_NULL,
    -25 => ARGON2_INCORRECT_PARAMETER,
    -26 => ARGON2_INCORRECT_TYPE,
    -27 => ARGON2_OUT_PTR_MISMATCH,
    -28 => ARGON2_THREADS_TOO_FEW,
    -29 => ARGON2_THREADS_TOO_MANY,
    -30 => ARGON2_MISSING_ARGS,
    -31 => ARGON2_ENCODING_FAIL,
    -32 => ARGON2_DECODING_FAIL,
    -33 => ARGON2_THREAD_FAIL,
    -34 => ARGON2_DECODING_LENGTH_FAIL,
    -35 => ARGON2_VERIFY_MISMATCH,
    _ => throw ArgumentError("Unknown value for Argon2_ErrorCodes: $value"),
  };
}

/// Context: structure to hold Argon2 inputs:
/// output array and its length,
/// password and its length,
/// salt and its length,
/// secret and its length,
/// associated data and its length,
/// number of passes, amount of used memory (in KBytes, can be rounded up a bit)
/// number of parallel threads that will be run.
/// All the parameters above affect the output hash value.
/// Additionally, two function pointers can be provided to allocate and
/// deallocate the memory (if NULL, memory will be allocated internally).
/// Also, three flags indicate whether to erase password, secret as soon as they
/// are pre-hashed (and thus not needed anymore), and the entire memory
///
/// Simplest situation: you have output array out[8], password is stored in
/// pwd[32], salt is stored in salt[16], you do not have keys nor associated
/// data. You need to spend 1 GB of RAM and you run 5 passes of Argon2d with
/// 4 parallel lanes.
/// You want to erase the password, but you're OK with last pass not being
/// erased. You want to use the default memory allocator.
/// Then you initialize:
/// Argon2_Context(out,8,pwd,32,salt,16,NULL,0,NULL,0,5,1<<20,4,4,NULL,NULL,true,false,false,false)
final class Argon2_Context extends ffi.Struct {
  /// output array
  external ffi.Pointer<ffi.Uint8> out;

  /// digest length
  @ffi.Uint32()
  external int outlen;

  /// password array
  external ffi.Pointer<ffi.Uint8> pwd;

  /// password length
  @ffi.Uint32()
  external int pwdlen;

  /// salt array
  external ffi.Pointer<ffi.Uint8> salt;

  /// salt length
  @ffi.Uint32()
  external int saltlen;

  /// key array
  external ffi.Pointer<ffi.Uint8> secret;

  /// key length
  @ffi.Uint32()
  external int secretlen;

  /// associated data array
  external ffi.Pointer<ffi.Uint8> ad;

  /// associated data length
  @ffi.Uint32()
  external int adlen;

  /// number of passes
  @ffi.Uint32()
  external int t_cost;

  /// amount of memory requested (KB)
  @ffi.Uint32()
  external int m_cost;

  /// number of lanes
  @ffi.Uint32()
  external int lanes;

  /// maximum number of threads
  @ffi.Uint32()
  external int threads;

  /// version number
  @ffi.Uint32()
  external int version;

  /// pointer to memory allocator
  external allocate_fptr allocate_cbk;

  /// pointer to memory deallocator
  external deallocate_fptr free_cbk;

  /// array of bool options
  @ffi.Uint32()
  external int flags;
}

/// Memory allocator types --- for external allocation
typedef allocate_fptr = ffi.Pointer<ffi.NativeFunction<allocate_fptrFunction>>;
typedef allocate_fptrFunction =
    ffi.Int Function(
      ffi.Pointer<ffi.Pointer<ffi.Uint8>> memory,
      ffi.Size bytes_to_allocate,
    );
typedef Dartallocate_fptrFunction =
    int Function(
      ffi.Pointer<ffi.Pointer<ffi.Uint8>> memory,
      int bytes_to_allocate,
    );
typedef deallocate_fptr =
    ffi.Pointer<ffi.NativeFunction<deallocate_fptrFunction>>;
typedef deallocate_fptrFunction =
    ffi.Void Function(
      ffi.Pointer<ffi.Uint8> memory,
      ffi.Size bytes_to_allocate,
    );
typedef Dartdeallocate_fptrFunction =
    void Function(ffi.Pointer<ffi.Uint8> memory, int bytes_to_allocate);

/// Argon2 primitive type
enum Argon2_type {
  Argon2_d(0),
  Argon2_i(1),
  Argon2_id(2);

  final int value;
  const Argon2_type(this.value);

  static Argon2_type fromValue(int value) => switch (value) {
    0 => Argon2_d,
    1 => Argon2_i,
    2 => Argon2_id,
    _ => throw ArgumentError("Unknown value for Argon2_type: $value"),
  };
}

/// Version of the algorithm
enum Argon2_version {
  ARGON2_VERSION_10(16),
  ARGON2_VERSION_13(19);

  static const ARGON2_VERSION_NUMBER = ARGON2_VERSION_13;

  final int value;
  const Argon2_version(this.value);

  static Argon2_version fromValue(int value) => switch (value) {
    16 => ARGON2_VERSION_10,
    19 => ARGON2_VERSION_13,
    _ => throw ArgumentError("Unknown value for Argon2_version: $value"),
  };

  @override
  String toString() {
    if (this == ARGON2_VERSION_13)
      return "Argon2_version.ARGON2_VERSION_13, Argon2_version.ARGON2_VERSION_NUMBER";
    return super.toString();
  }
}

/// Context: structure to hold Argon2 inputs:
/// output array and its length,
/// password and its length,
/// salt and its length,
/// secret and its length,
/// associated data and its length,
/// number of passes, amount of used memory (in KBytes, can be rounded up a bit)
/// number of parallel threads that will be run.
/// All the parameters above affect the output hash value.
/// Additionally, two function pointers can be provided to allocate and
/// deallocate the memory (if NULL, memory will be allocated internally).
/// Also, three flags indicate whether to erase password, secret as soon as they
/// are pre-hashed (and thus not needed anymore), and the entire memory
///
/// Simplest situation: you have output array out[8], password is stored in
/// pwd[32], salt is stored in salt[16], you do not have keys nor associated
/// data. You need to spend 1 GB of RAM and you run 5 passes of Argon2d with
/// 4 parallel lanes.
/// You want to erase the password, but you're OK with last pass not being
/// erased. You want to use the default memory allocator.
/// Then you initialize:
/// Argon2_Context(out,8,pwd,32,salt,16,NULL,0,NULL,0,5,1<<20,4,4,NULL,NULL,true,false,false,false)
typedef argon2_context = Argon2_Context;

const int ARGON2_MIN_LANES = 1;

const int ARGON2_MAX_LANES = 16777215;

const int ARGON2_MIN_THREADS = 1;

const int ARGON2_MAX_THREADS = 16777215;

const int ARGON2_SYNC_POINTS = 4;

const int ARGON2_MIN_OUTLEN = 4;

const int ARGON2_MAX_OUTLEN = 4294967295;

const int ARGON2_MIN_MEMORY = 8;

const int ARGON2_MAX_MEMORY_BITS = 32;

const int ARGON2_MAX_MEMORY = 4294967295;

const int ARGON2_MIN_TIME = 1;

const int ARGON2_MAX_TIME = 4294967295;

const int ARGON2_MIN_PWD_LENGTH = 0;

const int ARGON2_MAX_PWD_LENGTH = 4294967295;

const int ARGON2_MIN_AD_LENGTH = 0;

const int ARGON2_MAX_AD_LENGTH = 4294967295;

const int ARGON2_MIN_SALT_LENGTH = 8;

const int ARGON2_MAX_SALT_LENGTH = 4294967295;

const int ARGON2_MIN_SECRET = 0;

const int ARGON2_MAX_SECRET = 4294967295;

const int ARGON2_DEFAULT_FLAGS = 0;

const int ARGON2_FLAG_CLEAR_PASSWORD = 1;

const int ARGON2_FLAG_CLEAR_SECRET = 2;
